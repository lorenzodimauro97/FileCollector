@page "/"
@inject SettingsService SettingsService
@inject GitIgnoreFilterService GitIgnoreFilterService
@inject IJSRuntime JsRuntime
@inject ILogger<Index> Logger
@inject Func<Photino.NET.PhotinoWindow> MainWindowFactory
@using FileCollector.Services.Settings
@using System.IO
@using System.Text
@using System.Net

<PageTitle>File Explorer</PageTitle>

<div class="mb-3">
    <button class="btn btn-primary" @onclick="SelectFolderAndLoadTreeAsync" disabled="@_isLoading">
        <TablerIcon OutlineIcon="@TablerIconOutlineName.FolderOpen" Class="me-1" Size="16px"/>
        Select Root Folder
    </button>
    @if (!string.IsNullOrEmpty(_currentDisplayRootPath))
    {
        <p class="mt-2 mb-0">Current Folder: <strong title="@_currentDisplayRootPath">@_currentDisplayRootPath.Shorten(150)</strong></p>
    }
</div>

<h3>File Tree View</h3>

@if (_isLoading)
{
    <div class="alert alert-info mt-3" role="alert">
        <div class="d-flex align-items-center">
            <div class="spinner-border spinner-border-sm me-2" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <div>
                <strong>Loading...</strong>
                @if (!string.IsNullOrEmpty(_loadingMessage))
                {
                    <div class="small">@_loadingMessage</div>
                }
                else
                {
                    <div class="small">Please wait while the file tree is being processed.</div>
                }
            </div>
        </div>
    </div>
}
else if (!string.IsNullOrEmpty(_loadingMessage))
{
     <div class="alert @(_loadingMessage.StartsWith("Error") ? "alert-danger" : "alert-warning") mt-3" role="alert">
        @_loadingMessage
    </div>
}


@if (!_isLoading)
{
    <div style="height: 100vh">
    <div class="row">
        <div style="width: 25vw">
            <div class="row">
                <div class="col-12">
                    <h4>File System</h4>
                    <div class="file-tree-container border p-2 mb-3" style="max-height: 400px; overflow-y: auto;">
                        @if (string.IsNullOrEmpty(_currentDisplayRootPath) && string.IsNullOrEmpty(_loadingMessage))
                        {
                            <p>Please select a root folder to display its contents.</p>
                        }
                        else if (DisplayRootItems.Any())
                        {
                            @foreach (var item in DisplayRootItems.OrderBy(c => !c.IsDirectory).ThenBy(c => c.Name))
                            {
                                <FileTreeNode Node="item"
                                              SelectedFilePaths="_selectedFilePaths"
                                              OnSelectionChanged="HandleSelectionChangedAsync"
                                              Level="0"/>
                            }
                        }
                        else if (!string.IsNullOrEmpty(_currentDisplayRootPath) && string.IsNullOrEmpty(_loadingMessage))
                        {
                            <p>No files or directories to display in the current view. The folder might be empty or all items filtered.</p>
                        }
                    </div>
                </div>
                <div class="col-12">
                    <h4>Selected Files (@_selectedFilePaths.Count(p => GetNodeByPath(p) is { IsDirectory: false }))</h4>
                    @if (_selectedFilePaths.Any())
                    {
                        var selectedFileNodes = _selectedFilePaths
                            .Select(GetNodeByPath)
                            .Where(node => node is { IsDirectory: false })
                            .OrderBy(node => node!.FullPath)
                            .ToList();

                        if (selectedFileNodes.Any())
                        {
                            <div class="list-group mb-2" style="max-height: 200px; overflow-y: auto;"> @* Adjusted max-height *@
                                @foreach (var node in selectedFileNodes.OfType<FileSystemItem>())
                                {
                                    <div class="list-group-item list-group-item-action d-flex align-items-center py-1 px-2">
                                        <TablerIcon
                                            OutlineIcon="@IconHelper.GetIconForItem(node.Name, node.IsDirectory, node.IsExpanded)"
                                            Size="18px"
                                            Class="me-2 flex-shrink-0"
                                            Color="@(node.IsDirectory ? "var(--app-primary-color)" : "var(--sidebar-nav-link-color)")"/>
                                        <span class="text-truncate" title="@node.FullPath">@node.Name</span>
                                    </div>
                                }
                            </div>
                        }
                        else
                        {
                            <p>No files selected (only directories might be checked).</p>
                        }

                        <button class="btn btn-sm btn-outline-danger mt-2" @onclick="ClearAllSelectionsAsync" disabled="@_isLoading">
                            <TablerIcon OutlineIcon="@TablerIconOutlineName.Trash" Class="me-1" Size="16px"/>
                            Clear Selection
                        </button>
                    }
                    else
                    {
                        <p>No items selected.</p>
                    }
                </div>
            </div>
        </div>

        <div style="width: 60vw">
            <div class="sticky-top" style="top: 1rem;">
                <h4>
                    Merged Content
                    @if (_isMergingContent)
                    {
                        <span class="spinner-border spinner-border-sm ms-2" role="status" aria-hidden="true"></span>
                    }
                </h4>

                @if (!string.IsNullOrEmpty(_mergeErrorMessage))
                {
                    <div class="alert alert-danger small py-1 px-2">@_mergeErrorMessage</div>
                }

                @{
                    var selectedActualFilesCount = _selectedFilePaths.Count(p => GetNodeByPath(p) is { IsDirectory: false });
                }

                @if (selectedActualFilesCount > 0 || !string.IsNullOrEmpty(_mergedFileContentHtml))
                {
                    <div class="mb-2 d-flex align-items-center">
                        <button class="btn btn-sm btn-outline-secondary me-2" @onclick="GenerateMergedContentAsync" disabled="@(_isMergingContent || selectedActualFilesCount == 0)">
                            <TablerIcon OutlineIcon="@TablerIconOutlineName.Refresh" Class="me-1" Size="16px"/>
                            Refresh
                        </button>
                        <button class="btn btn-sm btn-outline-primary" @onclick="CopyMergedContentToClipboardAsync" disabled="@(_isMergingContent || string.IsNullOrEmpty(_mergedFileContentPlainText))">
                            <TablerIcon OutlineIcon="@TablerIconOutlineName.Clipboard" Class="me-1" Size="16px"/>
                            Copy
                        </button>
                        <span id="copyFeedback" class="ms-2 small"></span>
                    </div>

                    @if (!string.IsNullOrEmpty(_mergedFileContentHtml))
                    {
                        <div id="mergedContentViewer" class="merged-content-viewer" style="max-height: calc(100vh - 150px); overflow-y: auto; border: 1px solid #ced4da;"> @* Adjusted max-height to use viewport height *@
                            @((MarkupString)_mergedFileContentHtml)
                        </div>
                    }
                    else if (!_isMergingContent) 
                    {
                        <div class="merged-content-placeholder text-center p-3" style="min-height: 200px; border: 1px solid #ced4da; background-color: #f8f9fa; display: flex; align-items: center; justify-content: center;">
                            <p class="text-muted m-0">Select files to view merged content.</p>
                        </div>
                    }
                }
                else if (!_isMergingContent)
                {
                    <div class="merged-content-placeholder text-center p-3" style="min-height: 200px; border: 1px solid #ced4da; background-color: #f8f9fa; display: flex; align-items: center; justify-content: center;">
                        <p class="text-muted m-0">Select files from the tree to see their merged content.</p>
                    </div>
                }
            </div>
        </div>
    </div>
    </div>

}

@code {
    private List<FileSystemItem> _trueRootItems = [];
    private List<FileSystemItem> DisplayRootItems { get; set; } = [];
    private readonly List<string> _selectedFilePaths = [];
    private string? _currentDisplayRootPath;

    private bool _isLoading = false;
    private string _loadingMessage = "";

    private string _mergedFileContentHtml = "";
    private string _mergedFileContentPlainText = "";
    private bool _isMergingContent = false;
    private string _mergeErrorMessage = "";
    private bool _isDirtyMergedContent = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadFileTreeAsync(null);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_isDirtyMergedContent)
        {
            await JsRuntime.InvokeVoidAsync("blazorInterop.highlightAllSyntax");
            _isDirtyMergedContent = false;
        }
    }

    private async Task SelectFolderAndLoadTreeAsync()
    {
        var photinoWindow = MainWindowFactory();
        if (photinoWindow == null)
        {
            Logger.LogError("PhotinoWindow instance is not available. Cannot open folder dialog.");
            _loadingMessage = "Error: Could not access window features to open folder dialog.";
            StateHasChanged();
            return;
        }

        string[]? folderPathArray = await photinoWindow.ShowOpenFolderAsync("Select Root Folder");

        if (folderPathArray is { Length: > 0 } && !string.IsNullOrEmpty(folderPathArray[0]))
        {
            var selectedPath = folderPathArray[0];
            Logger.LogInformation("User selected folder: {SelectedPath}", selectedPath);
            await LoadFileTreeAsync(selectedPath);
        }
        else
        {
            Logger.LogInformation("Folder selection was cancelled or no folder was returned.");
        }
    }

    private async Task LoadFileTreeAsync(string? rootPath)
    {
        _isLoading = true;
        _loadingMessage = "Preparing to load...";
        _trueRootItems = [];
        DisplayRootItems = [];
        _selectedFilePaths.Clear();
        _currentDisplayRootPath = rootPath;

        _mergedFileContentHtml = "";
        _mergedFileContentPlainText = "";
        _mergeErrorMessage = "";
        _isDirtyMergedContent = false;

        StateHasChanged();

        if (string.IsNullOrEmpty(rootPath))
        {
            Logger.LogInformation("Root path is not set or cleared. File tree is empty.");
            _isLoading = false;
            _loadingMessage = "";
            StateHasChanged();
            return;
        }

        string currentProcessingPath = rootPath;
        List<FileSystemItem> newTrueRootItems = [];
        List<FileSystemItem> newDisplayRootItems = [];
        bool errorInBackgroundTask = false;
        string backgroundTaskMessage = "";

        try
        {
            await InvokeAsync(() => {
                _loadingMessage = $"Accessing folder: {currentProcessingPath.Shorten(100)}...";
                StateHasChanged();
            });

            await Task.Run(async () =>
            {
                try
                {
                    var exclusions = await SettingsService.GetIgnorePatternsAsync();

                    if (!Directory.Exists(currentProcessingPath))
                    {
                        backgroundTaskMessage = "Error: Selected folder does not exist.";
                        errorInBackgroundTask = true; return;
                    }

                    await InvokeAsync(() => {
                        _loadingMessage = $"Scanning file system entries in {currentProcessingPath.Shorten(100)}...";
                        StateHasChanged();
                    });

                    List<string> allEntries;
                    try
                    {
                        allEntries = IoService.GetFileSystemEntriesRecursive(currentProcessingPath).ToList();
                    }
                    catch (Exception ex)
                    {
                        backgroundTaskMessage = $"Error enumerating files: {ex.Message.Shorten(100)}";
                        errorInBackgroundTask = true; return;
                    }

                    if (!allEntries.Any())
                    {
                        backgroundTaskMessage = "No files or directories found in the selected folder.";
                        return;
                    }

                    await InvokeAsync(() => {
                        _loadingMessage = $"Filtering {allEntries.Count:N0} entries...";
                        StateHasChanged();
                    });
                    var filteredFullPaths = GitIgnoreFilterService.FilterPaths(allEntries, exclusions).ToList();

                    if (!filteredFullPaths.Any())
                    {
                        backgroundTaskMessage = "No items remain after filtering.";
                        return;
                    }
                    
                    await InvokeAsync(() => {
                        _loadingMessage = $"Building tree from {filteredFullPaths.Count:N0} paths...";
                        StateHasChanged();
                    });
                    newTrueRootItems = PathConverterService.BuildTree(filteredFullPaths);
                    FileSystemItem? displayRootNode = newTrueRootItems.FirstOrDefault(item => string.Equals(item.FullPath, currentProcessingPath, StringComparison.OrdinalIgnoreCase));

                    if (displayRootNode == null)
                    {
                        foreach (var trueRoot in newTrueRootItems)
                        {
                            displayRootNode = FindNodeRecursive(trueRoot, currentProcessingPath);
                            if (displayRootNode != null) break;
                        }
                    }

                    if (displayRootNode != null) newDisplayRootItems = displayRootNode.Children.ToList();
                    else
                    {
                        bool allTrueRootsAreDirectChildren = newTrueRootItems.Any() && newTrueRootItems.All(item =>
                            Path.GetDirectoryName(item.FullPath)?.Equals(currentProcessingPath.TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar), StringComparison.OrdinalIgnoreCase) == true);
                        if (allTrueRootsAreDirectChildren) newDisplayRootItems = newTrueRootItems;
                        else
                        {
                            backgroundTaskMessage = "Could not determine a clear root for display.";
                            newDisplayRootItems = [];
                        }
                    }
                    if (string.IsNullOrEmpty(backgroundTaskMessage) && !newDisplayRootItems.Any() && newTrueRootItems.Any()) {
                        backgroundTaskMessage = "Selected folder has content, but none to display at the root level after processing.";
                    }
                }
                catch (Exception ex)
                {
                    backgroundTaskMessage = $"Error during background processing: {ex.Message.Shorten(100)}";
                    errorInBackgroundTask = true;
                }
            });

            if (errorInBackgroundTask) _loadingMessage = backgroundTaskMessage;
            else
            {
                _trueRootItems = newTrueRootItems;
                DisplayRootItems = newDisplayRootItems;
                _loadingMessage = backgroundTaskMessage;
            }
        }
        catch (Exception ex)
        {
            _loadingMessage = $"Error: {ex.Message.Shorten(150)}";
            _trueRootItems = []; DisplayRootItems = [];
        }
        finally
        {
            _isLoading = false;
            if (DisplayRootItems.Any() && string.IsNullOrEmpty(_loadingMessage)) _loadingMessage = "";
            else if (string.IsNullOrEmpty(_currentDisplayRootPath)) _loadingMessage = "";
            StateHasChanged();
        }
    }

    private async Task HandleSelectionChangedAsync(FileSystemItem changedItem)
    {
        await GenerateMergedContentAsync();
    }

    private async Task ClearAllSelectionsAsync()
    {
        foreach (var trueRootItem in _trueRootItems)
        {
            DeselectNodeAndChildrenRecursive(trueRootItem);
        }
        _selectedFilePaths.Clear();
        
        _mergedFileContentHtml = "";
        _mergedFileContentPlainText = "";
        _mergeErrorMessage = "";
        _isMergingContent = false;
        _isDirtyMergedContent = false;

        StateHasChanged();
    }

    private static void DeselectNodeAndChildrenRecursive(FileSystemItem node)
    {
        node.IsSelected = false;
        if (node.IsDirectory)
        {
            foreach (var child in node.Children) DeselectNodeAndChildrenRecursive(child);
        }
    }

    private FileSystemItem? GetNodeByPath(string fullPath)
    {
        foreach (var trueRootItem in _trueRootItems)
        {
            var foundNode = FindNodeRecursive(trueRootItem, fullPath);
            if (foundNode != null) return foundNode;
        }
        return null;
    }

    private static FileSystemItem? FindNodeRecursive(FileSystemItem currentNode, string targetFullPath)
    {
        if (string.Equals(currentNode.FullPath, targetFullPath, StringComparison.OrdinalIgnoreCase)) return currentNode;
        if (currentNode.IsDirectory)
        {
            foreach (var child in currentNode.Children)
            {
                var foundInChild = FindNodeRecursive(child, targetFullPath);
                if (foundInChild != null) return foundInChild;
            }
        }
        return null;
    }

    private string GetLanguageClass(string fileName)
    {
        var extension = Path.GetExtension(fileName)?.ToLowerInvariant();
        return extension switch
        {
            ".cs" => "language-csharp",
            ".razor" => "language-markup", 
            ".html" => "language-markup",
            ".css" => "language-css",
            ".js" => "language-javascript",
            ".json" => "language-json",
            ".xml" => "language-xml",
            ".sql" => "language-sql",
            ".md" => "language-markdown",
            ".java" => "language-java",
            ".py" => "language-python",
            ".php" => "language-php",
            ".ts" => "language-typescript",
            ".tsx" => "language-tsx",
            ".jsx" => "language-jsx",
            ".csproj" => "language-xml",
            ".sln" => "language-none", 
            ".txt" => "language-none",
            _ => "language-none" 
        };
    }

    private async Task GenerateMergedContentAsync()
    {
        _isMergingContent = true;
        _mergeErrorMessage = "";
        StateHasChanged();

        var sbHtml = new StringBuilder();
        var sbPlainText = new StringBuilder();

        var filesToMerge = _selectedFilePaths
            .Select(GetNodeByPath)
            .Where(node => node is { IsDirectory: false })
            .OfType<FileSystemItem>()
            .OrderBy(node => node.FullPath)
            .ToList();

        if (!filesToMerge.Any())
        {
            _mergedFileContentHtml = "";
            _mergedFileContentPlainText = "";
            _isMergingContent = false;
            StateHasChanged();
            return;
        }

        bool anyFileReadError = false;
        foreach (var fileNode in filesToMerge)
        {
            try
            {
                var content = await File.ReadAllTextAsync(fileNode.FullPath);
                var languageClass = GetLanguageClass(fileNode.Name);
                var encodedContent = WebUtility.HtmlEncode(content.TrimEnd('\r', '\n'));
                var encodedFilePath = WebUtility.HtmlEncode(fileNode.FullPath);

                sbPlainText.AppendLine($"// File: {fileNode.FullPath}");
                sbPlainText.AppendLine("//--------------------------------------------------");
                sbPlainText.AppendLine(content.TrimEnd('\r', '\n'));
                sbPlainText.AppendLine("//--------------------------------------------------");
                sbPlainText.AppendLine($"// End of file: {fileNode.FullPath}");
                sbPlainText.AppendLine();
                sbPlainText.AppendLine();

                sbHtml.AppendLine(@"<div class=""file-block"">"); 
                sbHtml.AppendLine($@"  <p class=""file-header"">// File: {encodedFilePath}</p>");
                sbHtml.AppendLine($@"  <pre class=""line-numbers {languageClass}""><code class=""{languageClass}"">{encodedContent}</code></pre>");
                sbHtml.AppendLine($@"  <p class=""file-footer"">// End of file: {encodedFilePath}</p>");
                sbHtml.AppendLine(@"</div>");
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Error reading file for merging: {FilePath}", fileNode.FullPath);
                var encodedFilePath = WebUtility.HtmlEncode(fileNode.FullPath);
                var encodedError = WebUtility.HtmlEncode(ex.Message.Shorten(150));

                sbPlainText.AppendLine($"// File: {fileNode.FullPath}");
                sbPlainText.AppendLine($"// ERROR reading file: {ex.Message.Shorten(150)}");
                sbPlainText.AppendLine();
                sbPlainText.AppendLine();

                sbHtml.AppendLine(@"<div class=""file-block error-block"">");
                sbHtml.AppendLine($@"  <p class=""file-header"">// File: {encodedFilePath}</p>");
                sbHtml.AppendLine($@"  <pre><code class=""language-none"">// ERROR reading file: {encodedError}</code></pre>");
                sbHtml.AppendLine("</div>");
                
                _mergeErrorMessage = "One or more files could not be read. See content for details.";
            }
        }
        
        _mergedFileContentPlainText = sbPlainText.ToString().TrimEnd();
        _mergedFileContentHtml = sbHtml.ToString();
        _isMergingContent = false;
        _isDirtyMergedContent = true; 
        StateHasChanged();
    }

    private async Task CopyMergedContentToClipboardAsync()
    {
        if (!string.IsNullOrEmpty(_mergedFileContentPlainText))
        {
            try
            {
                await JsRuntime.InvokeVoidAsync("blazorInterop.copyToClipboard", _mergedFileContentPlainText, "copyFeedback");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "JavaScript interop for copyToClipboard failed.");
                var feedbackElement = await JsRuntime.InvokeAsync<bool>("eval", "document.getElementById('copyFeedback') != null");
                if (feedbackElement)
                {
                   await JsRuntime.InvokeVoidAsync("eval", "var el = document.getElementById('copyFeedback'); el.innerText = 'Copy init failed!'; el.style.color = 'red'; setTimeout(() => { el.innerText = ''; }, 3000);");
                }
            }
        }
    }
}