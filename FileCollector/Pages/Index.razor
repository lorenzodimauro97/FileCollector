@page "/"
@using System.Threading
@implements IAsyncDisposable
@inject SettingsService SettingsService
@inject NavigationStateService NavStateService
@inject IJSRuntime JsRuntime
@inject ILogger<Index> Logger
@inject Func<Photino.NET.PhotinoWindow> MainWindowFactory
@inject FileTreeService FileTreeSvc
@inject ContentMergingService ContentMergerSvc

<PageTitle>File Collector</PageTitle>

<div class="page-layout">
<div class="left-panel">
<div class="panel-section">
<button class="btn btn-primary btn-full-width" @onclick="SelectFolderAndLoadTreeAsync"
disabled="@_isLoading">
<TablerIcon OutlineIcon="@TablerIconOutlineName.FolderOpen" Class="me-1" Size="18px"/>
Select Root Folder
</button>
@if (!string.IsNullOrEmpty(_currentDisplayRootPath))
{
<p class="mt-2 mb-0 text-muted small">Current: <strong
title="@_currentDisplayRootPath">@_currentDisplayRootPath.Shorten(80)</strong></p>
}
</div>
@if (_isLoading && string.IsNullOrEmpty(_currentDisplayRootPath))
{
<div class="panel-section">
<div class="alert alert-info mt-3" role="alert">
<div class="d-flex align-items-center">
<div class="spinner-border spinner-border-sm me-2" role="status">
<span class="visually-hidden">Loading...</span>
</div>
<div>
<strong>Loading...</strong>
@if (!string.IsNullOrEmpty(_loadingMessage))
{
<div class="small">@_loadingMessage</div>
}
else
{
<div class="small">Please wait.</div>
}
</div>
</div>
</div>
</div>
}
else if (!string.IsNullOrEmpty(_loadingMessage) && _loadingMessage.StartsWith("Error"))
{
<div class="panel-section">
<div class="alert alert-danger mt-3" role="alert">
@_loadingMessage
</div>
</div>
}
else if (!string.IsNullOrEmpty(_loadingMessage))
{
<div class="panel-section">
<div class="alert alert-warning mt-3" role="alert">
@_loadingMessage
</div>
</div>
}
@if (!_isLoading || !string.IsNullOrEmpty(_currentDisplayRootPath))
{
<div class="panel-section">
<h4 class="panel-title">File System</h4>
<div class="file-tree-container scrollable-area">
@if (_isLoadingTree && !DisplayRootItems.Any())
{
<p class="text-muted">Loading tree...</p>
}
else if (string.IsNullOrEmpty(_currentDisplayRootPath) && string.IsNullOrEmpty(_loadingMessage) && !_isLoadingTree)
{
<p class="text-muted">Select a root folder.</p>
}
else if (DisplayRootItems.Any())
{
@foreach (var item in DisplayRootItems.OrderBy(c => !c.IsDirectory).ThenBy(c => c.Name))
{
<FileTreeNode Node="item"
SelectedFilePaths="_selectedFilePaths"
OnSelectionChanged="HandleSelectionChangedAsync"
Level="0"/>
}
}
else if (!string.IsNullOrEmpty(_currentDisplayRootPath) && string.IsNullOrEmpty(_loadingMessage) && !_isLoadingTree)
{
<p class="text-muted">No files or directories to display.</p>
}
</div>
</div>
<div class="panel-section">
            <h4 class="panel-title">
                Selected Files (@_selectedFilePaths.Count(p => GetNodeByPath(p) is { IsDirectory: false }))
            </h4>
            @if (_selectedFilePaths.Any())
            {
                var selectedFileNodes = _selectedFilePaths
                    .Select(GetNodeByPath)
                    .Where(node => node is { IsDirectory: false })
                    .OrderBy(node => node!.FullPath)
                    .ToList();

                if (selectedFileNodes.Any())
                {
                    <div class="selected-files-list scrollable-area-sm list-group">
                        @foreach (var node in selectedFileNodes.OfType<FileSystemItem>())
                        {
                            <div
                                class="list-group-item list-group-item-action d-flex align-items-center py-1 px-2">
                                <TablerIcon
                                    OutlineIcon="@IconHelper.GetIconForItem(node.Name, node.IsDirectory, node.IsExpanded)"
                                    Size="18px"
                                    Class="me-2 flex-shrink-0"
                                    Color="@(node.IsDirectory ? "var(--app-primary-color)" : "var(--text-color)")"/>
                                <span class="text-truncate" title="@node.FullPath">@node.Name</span>
                            </div>
                        }
                    </div>
                }
                else
                {
                    <p class="text-muted small">No files selected (only directories might be checked).</p>
                }

                <button class="btn btn-outline btn-sm mt-2" @onclick="ClearAllSelectionsAsync"
                        disabled="@_isLoading">
                    <TablerIcon OutlineIcon="@TablerIconOutlineName.Trash" Class="me-1" Size="16px"/>
                    Clear Selection
                </button>
            }
            else
            {
                <p class="text-muted small">No items selected.</p>
            }
        </div>
    }
</div>

<div class="right-panel">
    <div class="content-actions-area">
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h4 class="panel-title mb-0">
                Merged Content
                @if (_isMergingContent)
                {
                    <span class="spinner-border spinner-border-sm ms-2" role="status"
                          aria-hidden="true"></span>
                }
            </h4>
            <div class="d-flex align-items-center">
                <button class="btn btn-light me-2" @onclick="GenerateMergedContentAsync"
                        disabled="@(_isMergingContent || _selectedFilePaths.Count(p => GetNodeByPath(p) is { IsDirectory: false }) == 0)">
                    <TablerIcon OutlineIcon="@TablerIconOutlineName.Refresh" Class="me-1" Size="16px"/>
                    Refresh
                </button>
                <button class="btn btn-primary" @onclick="CopyMergedContentToClipboardAsync"
                        disabled="@(_isMergingContent || string.IsNullOrEmpty(_mergedFileContentPlainText))">
                    <TablerIcon OutlineIcon="@TablerIconOutlineName.Clipboard" Class="me-1" Size="16px"/>
                    Copy
                </button>
                <span id="copyFeedback" class="ms-2 small text-success"></span>
            </div>
        </div>

        @if (!string.IsNullOrEmpty(_mergeErrorMessage))
        {
            <div class="alert alert-danger small py-1 px-2">@_mergeErrorMessage</div>
        }

        <div class="mb-3">
            <label for="userPrompt" class="form-label">User Prompt:</label>
            <div class="input-group">
        <textarea id="userPrompt" class="form-control" rows="3"
                  value="@_userPrompt" @oninput="HandleUserPromptInput"
                  placeholder="Enter any specific instructions or questions here..."></textarea>
                <button class="btn btn-light" type="button" @onclick="ClearUserPromptAndRefresh"
                        title="Clear User Prompt">
                    <TablerIcon OutlineIcon="@TablerIconOutlineName.ClearAll" Size="16px"/>
                </button>
            </div>
            <div class="form-text">This prompt is not saved. It appears after files and before the Post-Prompt.
                Refreshes automatically after you stop typing.
            </div>
        </div>
    </div>

    <div class="merged-content-viewer scrollable-area">
        @{
            var selectedActualFilesCount = _selectedFilePaths.Count(p => GetNodeByPath(p) is { IsDirectory: false });
        }

        @if (selectedActualFilesCount > 0 || _mergedFilesToDisplay.Any())
        {
            @if (_mergedFilesToDisplay.Any())
            {
                <Virtualize Items="@_mergedFilesToDisplay" Context="fileItem">
                    <div @key="fileItem.FilePath" class="file-block @(fileItem.ErrorMessage != null ? "error-block" : "")">
                        <p class="file-header">
                            // File: @fileItem.RelativePath @(fileItem.ErrorMessage != null ? "(Error)" : "")
                        </p>

                        @if (fileItem.ErrorMessage != null)
                        {
                            <pre class="file-content-error"><code>@fileItem.Content</code></pre>
                        }
                        else if (fileItem.FilePath == "SYSTEM_PRE_PROMPT" || fileItem.FilePath == "SYSTEM_POST_PROMPT" || fileItem.FilePath == "SYSTEM_USER_PROMPT")
                        {
                            <pre class="file-content-system-prompt"><code>@fileItem.Content</code></pre>
                        }
                        else
                        {
                            <CodeHighlighter Content="@fileItem.Content"
                                             LanguageDefinition="@fileItem.Language"/>
                        }

                        <p class="file-footer">
                            // End of file: @fileItem.RelativePath
                        </p>
                    </div>
                </Virtualize>
            }
            else if (!_isMergingContent && selectedActualFilesCount > 0)
            {
                <div class="merged-content-placeholder">
                    <p class="text-muted m-0">Click "Refresh" to view merged content.</p>
                </div>
            }
            else if (!_isMergingContent)
            {
                <div class="merged-content-placeholder">
                    <p class="text-muted m-0">Select files to view merged content.</p>
                </div>
            }
        }
        else if (!_isMergingContent)
        {
            <div class="merged-content-placeholder">
                <p class="text-muted m-0">Select files from the tree to see their merged content.</p>
            </div>
        }
    </div>
</div>
</div>
@code {
    private List<FileSystemItem> _trueRootItems = [];
    private List<FileSystemItem> DisplayRootItems { get; set; } = [];
    private readonly List<string> _selectedFilePaths = [];
    private string? _currentDisplayRootPath;

    private bool _isLoading;
    private bool _isLoadingTree;
    private string _loadingMessage = "";

    private List<MergedFileDisplayItem> _mergedFilesToDisplay = [];
    private string _mergedFileContentPlainText = "";
    private bool _isMergingContent;
    private string _mergeErrorMessage = "";

    private string _userPrompt = "";
    private Timer? _userPromptDebounceTimer;
    private readonly TimeSpan _debounceTime = TimeSpan.FromMilliseconds(500);

    protected override async Task OnInitializedAsync()
    {
        var persistedState = NavStateService.ConsumePersistedState();
        if (persistedState?.RootPath != null)
        {
            _currentDisplayRootPath = persistedState.RootPath;
            var tempSelectedPaths = new List<string>(persistedState.SelectedFilePaths);

            await LoadFileTreeAsync(_currentDisplayRootPath);

            if (_trueRootItems.Any() || DisplayRootItems.Any())
            {
                foreach (var path in tempSelectedPaths)
                {
                    var node = GetNodeByPath(path);
                    if (node != null && !node.IsDirectory)
                    {
                        node.SetSelectionStatus(true, _selectedFilePaths);
                        node.UpdateParentSelectionStatus(_selectedFilePaths);
                    }
                }
            }

            await GenerateMergedContentAsync();
        }
    }

    private async Task SelectFolderAndLoadTreeAsync()
    {
        _isLoading = true;
        _loadingMessage = "Waiting for folder selection...";
        await InvokeAsync(StateHasChanged);

        var photinoWindow = MainWindowFactory();
        if (photinoWindow == null)
        {
            Logger.LogError("PhotinoWindow instance is not available. Cannot open folder dialog.");
            _loadingMessage = "Error: Could not access window features to open folder dialog.";
            _isLoading = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        string[]? folderPathArray = await photinoWindow.ShowOpenFolderAsync("Select Root Folder");
        _isLoading = false;
        _loadingMessage = "";

        if (folderPathArray is { Length: > 0 } && !string.IsNullOrEmpty(folderPathArray[0]))
        {
            var selectedPath = folderPathArray[0];
            Logger.LogInformation("User selected folder: {SelectedPath}", selectedPath);
            await LoadFileTreeAsync(selectedPath);
        }
        else
        {
            Logger.LogInformation("Folder selection was cancelled or no folder was returned.");
            if (string.IsNullOrEmpty(_currentDisplayRootPath))
            {
                _loadingMessage = "";
                DisplayRootItems.Clear();
            }

            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task LoadFileTreeAsync(string? rootPath)
    {
        _isLoadingTree = true;
        _loadingMessage = "Preparing to load file tree...";
        _trueRootItems = [];
        DisplayRootItems = [];
        _selectedFilePaths.Clear();
        _currentDisplayRootPath = rootPath;

        _mergedFilesToDisplay.Clear();
        _mergedFileContentPlainText = "";
        _mergeErrorMessage = "";

        await InvokeAsync(StateHasChanged);

        if (string.IsNullOrEmpty(rootPath))
        {
            Logger.LogInformation("Root path is not set or cleared. File tree is empty.");
            _isLoadingTree = false;
            _loadingMessage = "";
            await InvokeAsync(StateHasChanged);
            return;
        }

        FileTreeService.FileTreeLoadResult? result = null;
        try
        {
            var appSettings = await SettingsService.GetAppSettingsAsync();

            Action<string> reportProgressAction = newProgressMessage =>
            {
                InvokeAsync(() =>
                {
                    _loadingMessage = newProgressMessage;
                    StateHasChanged();
                });
            };

            result = await FileTreeSvc.LoadTreeAsync(rootPath, appSettings.IgnorePatterns, reportProgressAction);

            if (result.IsError)
            {
                _loadingMessage = result.Message;
                Logger.LogError("Error loading file tree: {ErrorMessage}", result.Message);
            }
            else
            {
                _trueRootItems = result.TrueRootItems;
                DisplayRootItems = result.DisplayRootItems;
                _loadingMessage = result.Message;
                if (string.IsNullOrEmpty(_loadingMessage) && !DisplayRootItems.Any() && !string.IsNullOrEmpty(rootPath))
                {
                    _loadingMessage = "No displayable files or folders found in the selected directory after processing.";
                }
            }
        }
        catch (Exception ex)
        {
            _loadingMessage = $"Error: {ex.Message.Shorten(150)}";
            Logger.LogError(ex, "Unhandled error in LoadFileTreeAsync for path {RootPath}", rootPath);
            _trueRootItems = [];
            DisplayRootItems = [];
        }
        finally
        {
            _isLoadingTree = false;
            if (DisplayRootItems.Any() && !string.IsNullOrEmpty(_loadingMessage) && result != null && !result.IsError && !_loadingMessage.Contains("No items") && !_loadingMessage.Contains("No displayable"))
            {
                _loadingMessage = "";
            }
            else if (string.IsNullOrEmpty(_currentDisplayRootPath))
            {
                _loadingMessage = "";
            }

            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task HandleSelectionChangedAsync(FileSystemItem changedItem)
    {
        await GenerateMergedContentAsync();
    }

    private async Task ClearUserPromptAndRefresh()
    {
        _userPrompt = "";
        _userPromptDebounceTimer?.Change(Timeout.Infinite, Timeout.Infinite);
        _userPromptDebounceTimer?.Dispose();
        _userPromptDebounceTimer = null;
        await GenerateMergedContentAsync();
    }

    private async Task HandleUserPromptInput(ChangeEventArgs e)
    {
        _userPrompt = e.Value?.ToString() ?? "";
        _userPromptDebounceTimer?.Change(Timeout.Infinite, Timeout.Infinite);
        _userPromptDebounceTimer?.Dispose();
        _userPromptDebounceTimer = new Timer(async _ => { await InvokeAsync(GenerateMergedContentAsync); }, null, (int)_debounceTime.TotalMilliseconds, Timeout.Infinite);
    }

    private async Task ClearAllSelectionsAsync()
    {
        foreach (var trueRootItem in _trueRootItems)
        {
            DeselectNodeAndChildrenRecursive(trueRootItem);
        }

        _selectedFilePaths.Clear();
        _mergedFilesToDisplay.Clear();
        _mergedFileContentPlainText = "";
        _mergeErrorMessage = "";
        _isMergingContent = false;
        await InvokeAsync(StateHasChanged);
    }

    private static void DeselectNodeAndChildrenRecursive(FileSystemItem node)
    {
        node.IsSelected = false;
        if (node.IsDirectory)
        {
            foreach (var child in node.Children) DeselectNodeAndChildrenRecursive(child);
        }
    }

    private FileSystemItem? GetNodeByPath(string fullPath)
    {
        foreach (var trueRootItem in _trueRootItems)
        {
            var foundNode = FindNodeRecursive(trueRootItem, fullPath);
            if (foundNode != null) return foundNode;
        }

        return null;
    }

    private static FileSystemItem? FindNodeRecursive(FileSystemItem currentNode, string targetFullPath)
    {
        if (string.Equals(currentNode.FullPath, targetFullPath, StringComparison.OrdinalIgnoreCase)) return currentNode;
        if (currentNode.IsDirectory)
        {
            foreach (var child in currentNode.Children)
            {
                var foundInChild = FindNodeRecursive(child, targetFullPath);
                if (foundInChild != null) return foundInChild;
            }
        }

        return null;
    }

    private async Task GenerateMergedContentAsync()
    {
        _isMergingContent = true;
        _mergeErrorMessage = "";
        _mergedFilesToDisplay.Clear();
        await InvokeAsync(StateHasChanged);

        var appSettings = await SettingsService.GetAppSettingsAsync();
        var filesToMerge = _selectedFilePaths
            .Select(GetNodeByPath)
            .Where(node => node is { IsDirectory: false })
            .OfType<FileSystemItem>()
            .OrderBy(node => node.FullPath)
            .ToList();

        if (!filesToMerge.Any() &&
            string.IsNullOrWhiteSpace(appSettings.PrePrompt) &&
            string.IsNullOrWhiteSpace(_userPrompt) &&
            string.IsNullOrWhiteSpace(appSettings.PostPrompt))
        {
            _mergedFileContentPlainText = "";
            _isMergingContent = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        var result = await ContentMergerSvc.GenerateMergedContentAsync(filesToMerge, appSettings, _userPrompt, _currentDisplayRootPath);

        _mergedFilesToDisplay = result.MergedFilesToDisplay;
        _mergedFileContentPlainText = result.MergedFileContentPlainText;
        _mergeErrorMessage = result.ErrorMessage;

        _isMergingContent = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task CopyMergedContentToClipboardAsync()
    {
        if (!string.IsNullOrEmpty(_mergedFileContentPlainText))
        {
            try
            {
                await JsRuntime.InvokeVoidAsync("blazorInterop.copyToClipboard", _mergedFileContentPlainText, "copyFeedback");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "JavaScript interop for copyToClipboard failed.");
                try
                {
                    await JsRuntime.InvokeVoidAsync("eval", @"
                    var el = document.getElementById('copyFeedback');
                    if(el) {
                        el.innerText = 'Copy init failed!'; el.style.color = 'var(--mantine-color-red-6)'; // Assuming Mantine color or fallback to 'red'
                        setTimeout(() => { if(el) el.innerText = ''; }, 3000);
                    }");
                }
                catch (JSException evalEx)
                {
                    Logger.LogError(evalEx, "Fallback JS for copy feedback also failed.");
                }
            }
        }
    }

    public ValueTask DisposeAsync()
    {
        NavStateService.SetPersistedState(_currentDisplayRootPath, _selectedFilePaths);
        _userPromptDebounceTimer?.Dispose();
        return ValueTask.CompletedTask;
    }
}