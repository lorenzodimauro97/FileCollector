@inject UpdateStateService UpdateStateSvc
@inject UpdateService UpdateSvc
@implements IAsyncDisposable

@if (_showModal)
{
    <div class="modal fade show" tabindex="-1" style="display: block; background-color: rgba(0,0,0,0.5);" role="dialog">
        <div class="modal-dialog modal-dialog-centered" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">
                        @switch (UpdateStateSvc.CurrentState)
                        {
                            case UpdateProcessState.UpdateAvailable:
                                <TablerIcon OutlineIcon="TablerIconOutlineName.Download" Class="me-2"/>
                                <span>Updates Available</span>
                                break;
                            case UpdateProcessState.Error:
                                <TablerIcon OutlineIcon="TablerIconOutlineName.AlertTriangle" Class="me-2"/>
                                <span>Update Error</span>
                                break;
                            default:
                                <TablerIcon OutlineIcon="TablerIconOutlineName.InfoCircle" Class="me-2"/>
                                <span>Application Update</span>
                                break;
                        }
                    </h5>
                    @if (CanCloseModal())
                    {
                        <button type="button" class="btn-close" @onclick="HandleDismissClicked" aria-label="Close"></button>
                    }
                </div>
                <div class="modal-body">
                    @if (!string.IsNullOrWhiteSpace(UpdateStateSvc.StatusMessage))
                    {
                        <p>@UpdateStateSvc.StatusMessage</p>
                    }

                    @if (UpdateStateSvc.CurrentState == UpdateProcessState.UpdateAvailable && UpdateStateSvc.AvailableUpdates.Any())
                    {
                        <p class="mt-1 mb-2">
                            <small>You are currently on version: @(_currentAppVersion)</small>
                        </p>

                        <div class="mb-3">
                            <label for="version-select" class="form-label fw-bold">Select version to install:</label>
                            <select id="version-select" class="form-select" @onchange="OnVersionSelected">
                                @foreach (var release in UpdateStateSvc.AvailableUpdates.OrderByDescending(r => r.PublishedAt))
                                {
                                    <option value="@release.TagName" selected="@(UpdateStateSvc.SelectedUpdate?.TagName == release.TagName)">
                                        @release.Name (@release.TagName)
                                    </option>
                                }
                            </select>
                        </div>

                        if (UpdateStateSvc.SelectedUpdate != null)
                        {
                            <h6 class="mt-3">Changes up to version @UpdateStateSvc.SelectedUpdate.TagName.TrimStart('v'):</h6>
                            <div class="release-notes scrollable-area-sm">
                                <MarkdownRenderer MarkdownContent="@GetCombinedReleaseNotes()" 
                                                  UseHardLineBreaks="true"
                                                  CustomTheme="@_lightThemeForMarkdown" />
                            </div>
                        }
                    }
                    else if (UpdateStateSvc.CurrentState != UpdateProcessState.UpdateAvailable && string.IsNullOrWhiteSpace(UpdateStateSvc.StatusMessage))
                    {
                        <p>Processing update status...</p>
                    }

                    @if (UpdateStateSvc.CurrentState is UpdateProcessState.Downloading or UpdateProcessState.Extracting)
                    {
                        <ProgressBar Value="@((int)UpdateStateSvc.Progress)" Max="100" ShowValue="true" Color="green"></ProgressBar>
                    }
                </div>
                <div class="modal-footer">
                    @switch (UpdateStateSvc.CurrentState)
                    {
                        case UpdateProcessState.UpdateAvailable:
                            <button type="button" class="btn btn-light" @onclick="HandleLaterClicked">Later</button>
                            <button type="button" class="btn btn-primary" @onclick="StartUpdateProcessAsync" disabled="@(UpdateStateSvc.SelectedUpdate == null)">
                                <TablerIcon OutlineIcon="TablerIconOutlineName.Download" Class="me-1"/>
                                Update to @UpdateStateSvc.SelectedUpdate?.TagName.TrimStart('v')
                            </button>
                            break;
                        case UpdateProcessState.ReadyToApply when UpdateStateSvc.StatusMessage != null && UpdateStateSvc.StatusMessage.Contains("Updater launched"):
                            <button type="button" class="btn btn-primary" disabled>Closing...</button>
                            break;
                        default:
                        {
                            if (CanCloseModal())
                            {
                                <button type="button" class="btn btn-primary" @onclick="HandleOkClicked">OK</button>
                            }

                            break;
                        }
                    }
                </div>
            </div>
        </div>
    </div>
}

@code {
    private bool _forceShowAfterUserCheck; 
    private string _currentAppVersion = "N/A";
    private bool _showModal;

    private readonly Dictionary<string, string> _lightThemeForMarkdown = new()
    {
        { "text", "#24292e" },
        { "heading", "#24292e" },
        { "link", "#0366d6" },
        { "border", "#e1e4e8" },
        { "code-background", "#f6f8fa" },
        { "blockquote-text", "#6a737d" },
        { "blockquote-border", "#dfe2e5" },
        { "inline-code-background", "rgba(27,31,35,.05)" }
    };

    protected override async Task OnInitializedAsync()
    {
        UpdateStateSvc.OnUpdateStateChangedAsync += HandleUpdateStateChangedAsync;
        _currentAppVersion = System.Reflection.Assembly.GetEntryAssembly()?.GetName().Version?.ToString() ?? "N/A";
        UpdateModalVisibility(); 

        var appSettings = await UpdateSvc.SettingsService.GetAppSettingsAsync();
        if (appSettings.Update.CheckForUpdatesOnStartup)
        {
            _ = UpdateSvc.CheckForUpdatesAsync();
        }
    }

    private async Task HandleUpdateStateChangedAsync()
    {
        UpdateModalVisibility();
        await InvokeAsync(StateHasChanged);
    }

    private void UpdateModalVisibility()
    {
        if (UpdateStateSvc.CurrentState == UpdateProcessState.Idle)
        {
            _showModal = _forceShowAfterUserCheck;
        }
        else
        {
            _showModal = true;
        }
    }

    private bool CanCloseModal()
    {
        return UpdateStateSvc.CurrentState switch
        {
            UpdateProcessState.Downloading => false,
            UpdateProcessState.Extracting => false,
            UpdateProcessState.Applying => false,
            _ => true,
        };
    }

    private void HandleDismissClicked()
    {
        if (!CanCloseModal()) return;

        if (UpdateStateSvc.CurrentState == UpdateProcessState.UpdateAvailable)
        {
            _showModal = false;
        }
        else
        {
            UpdateStateSvc.ResetState();
            _forceShowAfterUserCheck = false;
            _showModal = false;
        }
        StateHasChanged();
    }

    private void HandleLaterClicked()
    {
        _showModal = false;
        _forceShowAfterUserCheck = false;
        StateHasChanged();
    }

    private void HandleOkClicked()
    {
        UpdateStateSvc.ResetState();
        _forceShowAfterUserCheck = false;
        _showModal = false;
        StateHasChanged();
    }

    private async Task StartUpdateProcessAsync()
    {
        _forceShowAfterUserCheck = false;
        await UpdateSvc.DownloadAndApplyUpdateAsync();
    }

    private void OnVersionSelected(ChangeEventArgs e)
    {
        var selectedTag = e.Value?.ToString();
        if (string.IsNullOrEmpty(selectedTag)) return;

        var selectedRelease = UpdateStateSvc.AvailableUpdates.FirstOrDefault(r => r.TagName == selectedTag);
        if (UpdateStateSvc.SelectedUpdate == selectedRelease) return;
        UpdateStateSvc.SelectedUpdate = selectedRelease;
        StateHasChanged();
    }

    private string GetCombinedReleaseNotes()
    {
        if (UpdateStateSvc.SelectedUpdate == null) return "Select a version to see release notes.";

        if (!LargeVersion.TryParse(_currentAppVersion, out var currentVersion))
        {
            currentVersion = new LargeVersion(0);
        }

        if (!LargeVersion.TryParse(UpdateStateSvc.SelectedUpdate.TagName.TrimStart('v'), out var selectedVersion))
        {
            return $"Could not parse selected version tag: {UpdateStateSvc.SelectedUpdate.TagName}";
        }

        var updatesToInclude = UpdateStateSvc.AvailableUpdates
            .Select(r => new
            {
                Release = r,
                Version = LargeVersion.TryParse(r.TagName.TrimStart('v'), out var v) ? v : null
            })
            .Where(item =>
                item.Version != null &&
                item.Version.CompareTo(currentVersion) > 0 &&
                item.Version.CompareTo(selectedVersion) <= 0
            )
            .OrderByDescending(item => item.Version)
            .Select(item => item.Release)
            .ToList();
        
        if (!updatesToInclude.Any())
        {
            return !string.IsNullOrWhiteSpace(UpdateStateSvc.SelectedUpdate.Body) 
                ? UpdateStateSvc.SelectedUpdate.Body 
                : "No release notes provided for this version.";
        }

        var sb = new StringBuilder();
        foreach (var release in updatesToInclude)
        {
            sb.AppendLine($"# {release.Name} ({release.TagName})");
            sb.AppendLine(!string.IsNullOrWhiteSpace(release.Body) ? release.Body.Trim() : "No release notes provided for this version.");
            sb.AppendLine();
        }

        return sb.ToString().Trim();
    }


    public async Task CheckForUpdatesManuallyAsync()
    {
        _forceShowAfterUserCheck = true;
        await UpdateSvc.CheckForUpdatesAsync(initiatedByUser: true);
    }

    public async ValueTask DisposeAsync()
    {
        UpdateStateSvc.OnUpdateStateChangedAsync -= HandleUpdateStateChangedAsync;
        await Task.CompletedTask;
    }
}